## Codebase Patterns
- Frontend Tailwind: Tailwind CSS v4 uses `@tailwindcss/vite` plugin + `@import "tailwindcss"` in CSS (no tailwind.config.js needed)
- shadcn/ui: Requires `@/*` path aliases in BOTH `tsconfig.json` (root) AND `tsconfig.app.json` for CLI to detect
- shadcn/ui init: Use `npx shadcn@latest init -d` for non-interactive defaults; adds `components.json`, `src/lib/utils.ts`, CSS variables
- shadcn/ui add: Use `npx shadcn@latest add <component> -y` to add components non-interactively
- Frontend path aliases: Configure in `tsconfig.json` (for shadcn CLI), `tsconfig.app.json` (for TS), `vite.config.ts` (for Vite bundling)
- Frontend types: `src/types/` for shared TypeScript interfaces matching backend schemas
- Frontend hooks: `src/hooks/` for TanStack Query hooks (e.g., `usePositions`)
- TanStack Query: `QueryClientProvider` wraps App in `main.tsx`; `ReactQueryDevtools` added for dev
- Routing: React Router v7 from `react-router` package; `BrowserRouter` + `Routes` + `Route` in `App.tsx`
- Layout: Nested `<Route element={<Layout />}>` with `<Outlet />` for shared sidebar; `NavLink` for active state
- Auth guard: `<Route element={<AuthGuard />}>` wraps authenticated routes; redirects to `/login` via `<Navigate />`
- Pages: `src/pages/` for route components; `src/components/` for shared UI (Layout, AuthGuard)
- Supabase client: `src/lib/supabase.ts` initialized from `VITE_SUPABASE_URL` + `VITE_SUPABASE_ANON_KEY`
- Auth: `AuthProvider` in `src/contexts/AuthContext.tsx`; `useAuth()` hook from `src/hooks/useAuth.ts`
- API: `apiFetch()` in `src/lib/api.ts` — wraps fetch with auth token attachment; use `VITE_API_BASE_URL` env var
- By-ticker endpoint: Single query → `defaultdict(list)` grouping → compute per-ticker stats in Python
- PositionResponse.model_validate(): Reuse computed fields (annualized_roc) from schema for aggregation endpoints
- Dashboard endpoints: New router `app/routers/dashboard.py`; separate queries for date-scoped positions vs open positions
- Premium calculation: Closed positions use premium_net (total - open_fees - close_fees); open positions use premium_total
- Close/action endpoints: Use `POST /{id}/action` pattern; check status before mutating to return 400 for invalid state
- Literal types: Use `Literal["A", "B", "C"]` in Pydantic schemas for subset validation (e.g., close outcome excludes ROLLED)
- List endpoints: Use `Optional` query params with `Query(None)`, chain `.filter()` conditionally
- _FakeQuery: Add `.order_by()` method for mock chaining on list endpoints
- Compound endpoints: Use nested Pydantic schemas (e.g., `PositionRoll` with `close` and `open` sub-objects) for multi-operation payloads
- Atomicity: Single `db.commit()` after all mutations ensures both close + create happen in one transaction
- Config: Use pydantic-settings with `get_settings()` + `@lru_cache` for lazy loading
- Database: `app/database.py` has `Base`, `SessionLocal`, `get_db()` dependency
- Alembic: env.py imports `get_settings()` and `Base` from app modules
- Alembic migrations: Manual revision IDs (0002, 0003, ...), use `sa.text()` for server_default
- Migration tests: Use `importlib.util.spec_from_file_location` to load, mock `op` to verify structure
- ForeignKeyConstraint: Use `.column_keys` not `.columns` for unbound constraints
- Python: asdf with `.tool-versions` (python 3.10.4)
- Backend venv: `backend/.venv/` — activate with `source .venv/bin/activate`
- Tests: `backend/tests/` with pytest, run from backend dir
- Frontend: Vite + React 19 + TypeScript 5.9, strict mode
- CheckConstraint: Pass as positional arg to `op.create_table`, test via `isinstance(a, sa.CheckConstraint)`
- PostgreSQL arrays: Use `sa.ARRAY(sa.Text())` for `text[]` columns
- Indexes: `op.create_index` after `create_table`; test via `mock_op.create_index.call_args_list`
- Models: SQLAlchemy 2.0 `Mapped[]` + `mapped_column()` style in `app/models/`
- Models: `user_id` is plain Uuid (no FK in ORM) since FK targets cross-schema `auth.users.id`
- Models: Use `TYPE_CHECKING` guard for circular relationship imports between Account/Position
- Model tests: Use `sa_inspect(Model)` to verify columns, types, relationships without live DB
- Test env: `conftest.py` sets dummy env vars via `os.environ.setdefault` before app imports
- Auth: `app/auth.py` has `JWTAuthMiddleware` + `get_current_user` dependency returning `UUID`
- Auth: JWT verified via PyJWT with HS256, audience="authenticated", secret from `SUPABASE_JWT_SECRET`
- Auth: Public paths (`/health`, `/docs`, `/openapi.json`, `/redoc`) excluded in middleware
- Auth tests: Register test-only route at module level in test file, use `_make_token()` helper
- Schemas: `app/schemas/` with enums.py, account.py, position.py; all use Pydantic v2 `model_config`
- Schemas: `PositionResponse` uses `@computed_field` + `@property` for premium_total, premium_net, collateral, roc_period, dte, annualized_roc
- Schemas: `from_attributes=True` enables ORM model → Pydantic response via `model_validate(orm_obj)`
- Schemas: Enums are `str, Enum` subclasses for JSON serialization and string comparison
- Schemas: Access `model_fields` on the class, not the instance (Pydantic v2.11 deprecation)
- Routers: `app/routers/` with APIRouter, prefix `/api/v1/<resource>`, wired via `app.include_router()` in main.py
- Router tests: Use `app.dependency_overrides[get_db]` to inject mock DB session; clear in `finally` block
- Router tests: `_FakeQuery` helper class chains `.filter().all()` / `.filter().first()` for mock DB queries
- Router tests: Use `_make_account()` / `_make_token()` helpers for test fixtures
- Enum values: When storing Broker enum to DB, use `.value` to get the string (e.g., `body.broker.value`)
- PATCH pattern: `model_dump(exclude_unset=True)` + `setattr` loop; handle `.value`/`.upper()` in the loop
- Mock query sequencing: `mock_db.query.side_effect = [query1, query2]` for multiple distinct queries in one endpoint

---

## 2026-02-22 - US-001
- What was implemented:
  - Created `.env.example` documenting all required environment variables (SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY, DATABASE_URL, VITE_* frontend vars)
  - Created `backend/app/config.py` with pydantic-settings `Settings` class and lazy `get_settings()` loader
  - Created `backend/app/database.py` with SQLAlchemy engine, SessionLocal, Base, and `get_db()` dependency
  - Initialized Alembic (`backend/alembic/`) and configured `env.py` to use app config and Base metadata
  - Added `.tool-versions` for Python 3.10.4 via asdf
  - Created `backend/requirements-dev.txt` with test dependencies
  - Created initial tests (`tests/test_config.py`) for settings loading and health endpoint
- Files changed:
  - `.env.example` (new)
  - `.tool-versions` (new)
  - `backend/app/config.py` (new)
  - `backend/app/database.py` (new)
  - `backend/alembic/` (new — initialized)
  - `backend/alembic.ini` (new — generated)
  - `backend/alembic/env.py` (modified — connected to app config)
  - `backend/requirements-dev.txt` (new)
  - `backend/tests/__init__.py` (new)
  - `backend/tests/test_config.py` (new)
- **Learnings:**
  - pydantic-settings eagerly validates at import time; use `@lru_cache` + getter function to avoid import-time failures in tests
  - Alembic init generates a default env.py that needs to be wired to the app's Base.metadata and config
  - The project uses asdf for version management; must set `.tool-versions` before Python commands work
---

## 2026-02-22 - US-002
- What was implemented:
  - Created Alembic migration `0002_create_accounts_table.py` with all required columns (id, user_id, name, broker, tax_treatment, created_at, updated_at)
  - id is uuid PK with `gen_random_uuid()` server default
  - user_id has FK constraint to `auth.users.id` (Supabase auth)
  - created_at and updated_at use `now()` server defaults with timezone=True
  - Downgrade drops the table
  - Created `tests/test_migrations.py` with 8 tests verifying migration structure via mocked `op`
- Files changed:
  - `backend/alembic/versions/0002_create_accounts_table.py` (new)
  - `backend/tests/test_migrations.py` (new)
- **Learnings:**
  - `ForeignKeyConstraint.columns` is empty until bound to a table; use `.column_keys` for assertions
  - Can't `importlib.import_module("alembic.versions.xxx")` — alembic.versions is part of alembic's package namespace; use `spec_from_file_location` instead
  - Mocking `op` is a clean way to test migration structure without needing a live database
---

## 2026-02-22 - US-003
- What was implemented:
  - Created Alembic migration `0003_create_positions_table.py` with all 22 columns from the spec
  - Columns: id (uuid PK), user_id, account_id, ticker, type, status (default OPEN), open_date, expiration_date, close_date, strike_price (numeric), contracts (int), multiplier (int default 100), premium_per_share (numeric), open_fees (numeric default 0), close_fees (numeric default 0), close_price_per_share, outcome, roll_group_id, notes, tags (text[]), created_at, updated_at
  - FK constraints to `auth.users.id` and `accounts.id`
  - CHECK constraints on type (COVERED_CALL, CASH_SECURED_PUT), status (OPEN, CLOSED), outcome (EXPIRED, ASSIGNED, CLOSED_EARLY, ROLLED)
  - Three composite indexes: (user_id, status), (user_id, ticker), (user_id, expiration_date)
  - Downgrade drops indexes then table
  - Added 10 tests to `tests/test_migrations.py` covering structure, columns, types, nullability, FKs, CHECKs, indexes, and downgrade
- Files changed:
  - `backend/alembic/versions/0003_create_positions_table.py` (new)
  - `backend/tests/test_migrations.py` (modified — added TestPositionsMigration)
- **Learnings:**
  - `sa.CheckConstraint` objects can be passed as positional args to `op.create_table` alongside columns and FK constraints
  - `sa.ARRAY(sa.Text())` is the correct SQLAlchemy type for PostgreSQL `text[]` columns
  - Indexes created via `op.create_index` are separate calls after `create_table`; test them via `mock_op.create_index.call_args_list`
---

## 2026-02-22 - US-004
- What was implemented:
  - Created `app/models/account.py` — Account ORM model with all 7 columns mapped via `mapped_column()` (SQLAlchemy 2.0)
  - Created `app/models/position.py` — Position ORM model with all 22 columns including `tags` as `ARRAY(Text)`
  - Defined relationships: `Account.positions` (one-to-many) and `Position.account` (many-to-one) with `back_populates`
  - Updated `app/models/__init__.py` to export both models
  - Created `tests/conftest.py` to set dummy env vars for test imports
  - Created `tests/test_models.py` with 16 tests covering columns, types, nullability, PKs, FKs, relationships, and Mapped[] style
- Files changed:
  - `backend/app/models/account.py` (new)
  - `backend/app/models/position.py` (new)
  - `backend/app/models/__init__.py` (modified)
  - `backend/tests/conftest.py` (new)
  - `backend/tests/test_models.py` (new)
- **Learnings:**
  - `user_id` FK to `auth.users.id` (Supabase cross-schema) is omitted from ORM model to avoid metadata resolution issues; migration handles the FK
  - `sa_inspect(Model)` provides clean access to column_attrs, relationships, and primary_key for structural tests
  - `TYPE_CHECKING` guard is needed for circular imports between Account/Position relationship types
  - Column named `type` needs explicit name arg `mapped_column("type", Text, ...)` to avoid ambiguity
  - `conftest.py` with `os.environ.setdefault` is the cleanest way to handle env vars for tests that import app modules
---

## 2026-02-22 - US-005
- What was implemented:
  - Created `app/auth.py` with `JWTAuthMiddleware` (Starlette BaseHTTPMiddleware) and `get_current_user` FastAPI dependency
  - Middleware verifies Supabase JWTs (HS256 + shared secret) on every request except public paths (/health, /docs, /openapi.json, /redoc)
  - Extracts `sub` claim as `user_id`, stores in `request.state.user_id`
  - `get_current_user` reads from `request.state` and returns `UUID`
  - Added `SUPABASE_JWT_SECRET` to Settings config, `.env.example`, and test conftest
  - Added `PyJWT>=2.8` to requirements.txt
  - Wired middleware into `app/main.py`
  - Created `tests/test_auth.py` with 10 tests covering: health bypass, missing header, invalid format, invalid token, expired token, wrong secret, wrong audience, missing sub claim, valid token returns user_id, UUID type check
- Files changed:
  - `backend/app/auth.py` (new)
  - `backend/app/main.py` (modified — added JWTAuthMiddleware)
  - `backend/app/config.py` (modified — added supabase_jwt_secret)
  - `backend/requirements.txt` (modified — added PyJWT)
  - `.env.example` (modified — added SUPABASE_JWT_SECRET)
  - `backend/tests/conftest.py` (modified — added SUPABASE_JWT_SECRET env var)
  - `backend/tests/test_auth.py` (new)
- **Learnings:**
  - Starlette `BaseHTTPMiddleware` with `dispatch()` is the simplest way to add request-level auth in FastAPI
  - PyJWT `jwt.decode()` with `audience` param enforces the `aud` claim automatically
  - `request.state` is the standard way to pass data from middleware to dependencies
  - Register test-only routes at module level (not inside test functions) to avoid issues with FastAPI route registration
  - `HTTPBearer(auto_error=False)` in the dependency prevents double-401 (middleware already handles it)
---

## 2026-02-22 - US-006
- What was implemented:
  - Created `app/schemas/enums.py` with str Enum classes: PositionType, PositionStatus, PositionOutcome, Broker
  - Created `app/schemas/account.py` with AccountCreate, AccountUpdate, AccountResponse (Pydantic v2)
  - Created `app/schemas/position.py` with PositionCreate, PositionUpdate, PositionResponse (Pydantic v2)
  - PositionResponse includes 6 computed fields: premium_total, premium_net, collateral, roc_period, dte, annualized_roc
  - All schemas use `model_config = ConfigDict(...)` (Pydantic v2 style)
  - Response schemas use `from_attributes=True` for ORM compatibility
  - Updated `app/schemas/__init__.py` to re-export all schemas and enums
  - Created `tests/test_schemas.py` with 43 tests covering enums, create/update/response for both accounts and positions, computed field calculations, validation errors, and Pydantic v2 config
- Files changed:
  - `backend/app/schemas/enums.py` (new)
  - `backend/app/schemas/account.py` (new)
  - `backend/app/schemas/position.py` (new)
  - `backend/app/schemas/__init__.py` (modified — added re-exports)
  - `backend/tests/test_schemas.py` (new)
- **Learnings:**
  - Pydantic v2 `@computed_field` requires `@property` decorator underneath and `# type: ignore[prop-decorator]` for mypy
  - `str, Enum` base classes make enums JSON-serializable and comparable to plain strings
  - `from_attributes=True` in model_config enables `ModelClass.model_validate(orm_object)` for ORM → Pydantic conversion
  - `model_fields` should be accessed on the class not instance (deprecated in Pydantic v2.11)
  - Computed fields for annualized_roc need zero-guard on both collateral and days_in_trade
---

## 2026-02-22 - US-007
- What was implemented:
  - Created `app/routers/accounts.py` with 3 CRUD endpoints:
    - `GET /api/v1/accounts` — lists authenticated user's accounts
    - `POST /api/v1/accounts` — creates account with name, broker, optional tax_treatment (returns 201)
    - `PATCH /api/v1/accounts/{id}` — updates account fields; returns 404 if not found or belongs to another user
  - All endpoints use `get_current_user` dependency to scope queries by `user_id`
  - All responses use `AccountResponse` schema with `from_attributes=True` for ORM → Pydantic conversion
  - Wired router into `app/main.py` via `app.include_router()`
  - Created `tests/test_accounts.py` with 13 tests covering: list (2), auth (1), create (4), update (5), schema validation (1)
  - Tests use `dependency_overrides[get_db]` with mock DB session (no live DB needed)
- Files changed:
  - `backend/app/routers/accounts.py` (new)
  - `backend/app/main.py` (modified — added router import and include)
  - `backend/tests/test_accounts.py` (new)
- **Learnings:**
  - `app.dependency_overrides[get_db]` is the standard FastAPI testing pattern to inject mock DB without real connections
  - Broker enum `.value` must be extracted when setting on ORM model to store the raw string
  - `exclude_unset=True` in `model_dump()` is critical for PATCH — only applies fields the client actually sent
  - Filter by both `Account.id == account_id` and `Account.user_id == user_id` in a single query ensures user isolation and returns 404 for other users' accounts
---

## 2026-02-22 - US-008
- What was implemented:
  - Created `app/routers/positions.py` with `POST /api/v1/positions` endpoint
  - Validates `account_id` belongs to authenticated user (returns 400 if not)
  - Uppercases `ticker` before storage
  - Creates position with all required fields + optional fields (multiplier, open_fees, notes, tags)
  - Returns `PositionResponse` with computed fields (premium_total, premium_net, collateral, roc_period, dte, annualized_roc)
  - Wired router into `app/main.py` via `app.include_router()`
  - Created `tests/test_positions.py` with 9 tests covering: success, ticker uppercase, invalid account (400), optional fields, auth required (401), missing fields (422), invalid type (422), computed fields verification, CASH_SECURED_PUT type
- Files changed:
  - `backend/app/routers/positions.py` (new)
  - `backend/app/main.py` (modified — added positions router)
  - `backend/tests/test_positions.py` (new)
- **Learnings:**
  - Account ownership validation for positions uses same `_FakeQuery` pattern but returns 400 (not 404) since it's a validation error on the request body
  - `body.type.value` extracts the enum string value for storage in the ORM model (same pattern as Broker enum)
  - `body.ticker.upper()` handles ticker uppercasing at the router level, not schema level
  - Mock `db.refresh()` side_effect must set all fields the ORM object would have after DB round-trip, including server defaults (status, close_fees, etc.)
---

## 2026-02-22 - US-009
- What was implemented:
  - Added `GET /api/v1/positions` endpoint to `app/routers/positions.py` with filtering and sorting
  - Supports query params: status, ticker, type, account_id, expiration_start, expiration_end, sort, order (asc/desc)
  - Default sort is `open_date` descending
  - Ticker filter is case-insensitive (uppercased before comparison)
  - Invalid sort columns fall back to `open_date`
  - Returns empty list (not error) when no positions match
  - Each position includes computed fields via `PositionResponse`
  - Added 11 tests covering: list (2), filters (status, ticker, type, account_id, expiration range), sorting (2), computed fields, auth
  - Updated `_FakeQuery` to support `.order_by()` chaining
- Files changed:
  - `backend/app/routers/positions.py` (modified — added GET endpoint, imports, SORTABLE_COLUMNS)
  - `backend/tests/test_positions.py` (modified — added 11 GET tests, updated _FakeQuery)
- **Learnings:**
  - `Optional` query params with `Query(None)` cleanly handle optional filters — only add `.filter()` when param is not None
  - `getattr(Position, sort_col_name)` dynamically resolves ORM columns for sorting; validate against a whitelist to prevent injection
  - Enum query params (PositionStatus, PositionType) are auto-validated by FastAPI; use `.value` to compare against DB strings
  - `_FakeQuery.order_by()` just returns `self` since mock doesn't need real sorting — tests verify the endpoint accepts sort params without error
---

## 2026-02-22 - US-010
- What was implemented:
  - Added `PATCH /api/v1/positions/{id}` endpoint to `app/routers/positions.py`
  - Updates any subset of editable fields via `PositionUpdate` schema (excludes `user_id`, `status`, `outcome`)
  - Returns 404 if position doesn't exist or belongs to another user
  - Cannot change `user_id` (field not in `PositionUpdate` schema, so it's silently ignored)
  - Ticker is uppercased if provided; type enum stored as `.value` string
  - Validates new `account_id` belongs to user if provided (returns 400 if not)
  - `updated_at` refreshed via `db.commit()` + `db.refresh()` (server-side default)
  - Response includes recalculated computed fields
  - Added 11 tests covering: success, not found, other user's position, cannot change user_id, ticker uppercase, type enum storage, invalid account_id, updated_at refresh, computed fields, auth required, exclude_unset behavior
- Files changed:
  - `backend/app/routers/positions.py` (modified — added PATCH endpoint, imported PositionUpdate)
  - `backend/tests/test_positions.py` (modified — added 11 PATCH tests)
- **Learnings:**
  - `model_dump(exclude_unset=True)` is critical for PATCH — only applies fields the client actually sent, preserving other fields
  - When an endpoint makes multiple different `db.query()` calls (e.g., Position lookup then Account validation), use `mock_db.query.side_effect = [query1, query2]` instead of `return_value`
  - Enum and ticker transformations (`.value`, `.upper()`) should happen in the `setattr` loop to handle both create and update consistently
  - `PositionUpdate` schema excluding `user_id` is the cleanest way to enforce "cannot change user_id" — no explicit validation needed
---

## 2026-02-22 - US-011
- What was implemented:
  - Added `PositionClose` Pydantic schema with `outcome` (Literal["EXPIRED", "ASSIGNED", "CLOSED_EARLY"]), `close_date`, optional `close_price_per_share`, optional `close_fees`
  - Added `POST /api/v1/positions/{id}/close` endpoint to `app/routers/positions.py`
  - Endpoint looks up position by id + user_id, returns 404 if not found
  - Returns 400 if position is already CLOSED
  - Sets status to CLOSED, outcome, close_date, and optional close_price_per_share/close_fees
  - Response includes recalculated computed fields (premium_net reflects close_fees)
  - Added 10 tests covering: success, ASSIGNED outcome, CLOSED_EARLY with close_price/fees, already closed (400), not found (404), other user (404), invalid outcome ROLLED (422), computed fields verification, auth required (401), missing required fields (422)
- Files changed:
  - `backend/app/schemas/position.py` (modified — added PositionClose)
  - `backend/app/schemas/__init__.py` (modified — added PositionClose export)
  - `backend/app/routers/positions.py` (modified — added close endpoint, imported PositionClose)
  - `backend/tests/test_positions.py` (modified — added 10 close tests)
- **Learnings:**
  - `Literal["EXPIRED", "ASSIGNED", "CLOSED_EARLY"]` in Pydantic schema is cleaner than a separate enum for subset validation — gives automatic 422 for ROLLED
  - Action endpoints (close, roll) use `POST /{id}/action` pattern vs `PATCH /{id}` for updates
  - Check `position.status == "CLOSED"` before mutating to return 400 for already-closed positions
  - Optional close fields (`close_price_per_share`, `close_fees`) only set when provided (not None) to avoid overwriting defaults
---

## 2026-02-22 - US-012
- What was implemented:
  - Added `PositionRollClose`, `PositionRoll`, and `PositionRollResponse` Pydantic schemas to `app/schemas/position.py`
  - `PositionRoll` uses nested schemas: `close` (PositionRollClose) and `open` (PositionCreate) for the two-part payload
  - `PositionRollResponse` returns both `closed` and `opened` PositionResponse objects
  - Added `POST /api/v1/positions/{id}/roll` endpoint to `app/routers/positions.py`
  - Endpoint: looks up position (404 if not found), checks not already closed (400), validates new account_id (400), generates shared `roll_group_id`, closes old position with outcome=ROLLED, creates new position, single `db.commit()` for atomicity
  - Returns both closed and opened positions with computed fields
  - Updated `app/schemas/__init__.py` to export new schemas
  - Added 11 tests covering: success, close_price/fees, not found (404), other user (404), already closed (400), invalid account (400), atomic transaction, ticker uppercase, computed fields, auth required (401), missing fields (422)
- Files changed:
  - `backend/app/schemas/position.py` (modified — added PositionRollClose, PositionRoll, PositionRollResponse)
  - `backend/app/schemas/__init__.py` (modified — added new exports)
  - `backend/app/routers/positions.py` (modified — added roll endpoint, imported new schemas + uuid4)
  - `backend/tests/test_positions.py` (modified — added 11 roll tests)
- **Learnings:**
  - Nested Pydantic schemas (close + open sub-objects) cleanly model compound operations like roll
  - Reusing `PositionCreate` as the `open` field type in `PositionRoll` avoids duplicating validation logic
  - Single `db.commit()` after both close mutation and `db.add(new_position)` ensures atomicity without explicit transaction management
  - `mock_db.query.side_effect = [position_query, account_query]` handles the two sequential queries (Position lookup then Account validation)
  - `fake_refresh` with a counter (`refresh_call_count`) differentiates between refreshing the closed position vs the new position
  - Outcome is hardcoded to "ROLLED" in the endpoint (not sent by client), unlike the close endpoint which accepts outcome from the client
---

## 2026-02-22 - US-013
- What was implemented:
  - Created `app/schemas/dashboard.py` with `DashboardSummaryResponse` schema (total_premium_collected, premium_mtd, open_position_count, upcoming_expirations)
  - Created `app/routers/dashboard.py` with `GET /api/v1/dashboard/summary` endpoint
  - Supports optional `start`/`end` date query params to scope total_premium_collected by open_date
  - `total_premium_collected`: premium_net for closed positions + premium_total for open
  - `premium_mtd`: same calculation filtered to current month
  - `open_position_count`: count of OPEN positions (not date-scoped)
  - `upcoming_expirations`: OPEN positions expiring within 7 days, returned as full PositionResponse objects with computed fields
  - Returns zeroes and empty list when no data exists
  - Wired router into `app/main.py`
  - Updated `app/schemas/__init__.py` with `DashboardSummaryResponse` export
  - Created `tests/test_dashboard.py` with 9 tests covering: no data (zeroes), mixed open/closed, MTD scoping, upcoming expirations 7-day cutoff, date range params, closed premium_net, open premium_total, auth required, computed fields in upcoming expirations
- Files changed:
  - `backend/app/schemas/dashboard.py` (new)
  - `backend/app/routers/dashboard.py` (new)
  - `backend/app/main.py` (modified — added dashboard router)
  - `backend/app/schemas/__init__.py` (modified — added DashboardSummaryResponse)
  - `backend/tests/test_dashboard.py` (new)
- **Learnings:**
  - Dashboard endpoint uses two separate DB queries: one for date-scoped positions (all statuses) and one for open positions
  - Premium calculation varies by status: closed uses premium_net (total - fees), open uses premium_total (fees unknown yet)
  - MTD filtering is done in Python from the already-fetched positions, not as a separate query
  - `mock_db.query.side_effect = [all_query, open_query]` handles the two sequential queries in the endpoint
  - `upcoming_expirations` returns full PositionResponse objects (with computed fields), not a simple count
---

## 2026-02-22 - US-014
- What was implemented:
  - Added `TickerSummary` Pydantic schema to `app/schemas/dashboard.py` with fields: ticker, total_premium, trade_count, avg_annualized_roc
  - Added `GET /api/v1/dashboard/by-ticker` endpoint to `app/routers/dashboard.py`
  - Supports optional `start`/`end` date query params to scope by open_date
  - Groups positions by ticker using `defaultdict(list)`
  - Computes total_premium using same `_compute_premium()` helper (closed → premium_net, open → premium_total)
  - Computes avg_annualized_roc by validating each position through `PositionResponse.model_validate()` to leverage computed fields
  - Results sorted by total_premium descending
  - Returns empty list when no positions exist
  - Updated `app/schemas/__init__.py` to export `TickerSummary`
  - Added 7 tests covering: empty data, grouping, sorting, date range, avg_annualized_roc, premium calculation (open vs closed), auth required
- Files changed:
  - `backend/app/schemas/dashboard.py` (modified — added TickerSummary)
  - `backend/app/routers/dashboard.py` (modified — added by-ticker endpoint, new imports)
  - `backend/app/schemas/__init__.py` (modified — added TickerSummary export)
  - `backend/tests/test_dashboard.py` (modified — added 7 by-ticker tests)
- **Learnings:**
  - `PositionResponse.model_validate(orm_mock)` reuses computed fields (annualized_roc) without reimplementing the calculation
  - `defaultdict(list)` is cleaner than manual grouping for Python-side aggregation
  - By-ticker endpoint uses a single DB query (unlike summary which uses two) since it doesn't need separate open-position queries
  - `mock_db.query.return_value` (not `side_effect`) works for single-query endpoints
---

## 2026-02-22 - US-015
- What was implemented:
  - Installed Tailwind CSS v4 (`tailwindcss`, `@tailwindcss/vite`) and configured as a Vite plugin
  - Set up `@/` path aliases in `tsconfig.json`, `tsconfig.app.json`, and `vite.config.ts` (all three needed)
  - Replaced boilerplate `index.css` with Tailwind import; shadcn/ui init added CSS variables and theme config
  - Initialized shadcn/ui (`npx shadcn@latest init -d`): created `components.json`, `src/lib/utils.ts` (cn utility), installed `clsx`, `tailwind-merge`, `class-variance-authority`, `radix-ui`, `lucide-react`, `tw-animate-css`
  - Added Button component via `npx shadcn@latest add button -y`
  - Updated `App.tsx` to use shadcn/ui Button with Tailwind utility classes, removed Vite boilerplate
  - Cleared `App.css` (no longer needed with Tailwind)
  - TypeScript typecheck and Vite production build both pass
- Files changed:
  - `frontend/package.json` (modified — new dependencies)
  - `frontend/vite.config.ts` (modified — added tailwindcss plugin and path aliases)
  - `frontend/tsconfig.json` (modified — added compilerOptions with path aliases)
  - `frontend/tsconfig.app.json` (modified — added path aliases)
  - `frontend/src/index.css` (rewritten — Tailwind import + shadcn/ui CSS variables)
  - `frontend/src/App.tsx` (rewritten — uses shadcn/ui Button with Tailwind classes)
  - `frontend/src/App.css` (cleared — replaced by Tailwind utilities)
  - `frontend/components.json` (new — shadcn/ui configuration)
  - `frontend/src/lib/utils.ts` (new — cn utility function)
  - `frontend/src/components/ui/button.tsx` (new — shadcn/ui Button component)
- **Learnings:**
  - Tailwind CSS v4 no longer uses `tailwind.config.js`; configuration is done via CSS `@theme` blocks and the `@tailwindcss/vite` plugin
  - shadcn/ui CLI reads `tsconfig.json` (root), not `tsconfig.app.json` — path aliases must be in the root tsconfig for the CLI to validate
  - `npx shadcn@latest init -d` uses all defaults (new-york style, neutral base color, CSS variables enabled) — fully non-interactive
  - shadcn/ui v4 (Tailwind v4 compatible) uses `@import "shadcn/tailwind.css"` and `@import "tw-animate-css"` instead of manual plugin configs
  - The `--style new-york` is the default for shadcn/ui and includes smaller, more refined components
---

## 2026-02-22 - US-016
- What was implemented:
  - Installed `@tanstack/react-table`, `@tanstack/react-query`, and `@tanstack/react-query-devtools`
  - Created `QueryClient` in `main.tsx` and wrapped App with `QueryClientProvider`
  - Added `ReactQueryDevtools` component (visible in development only)
  - Created TypeScript types for Position (`src/types/position.ts`) matching backend `PositionResponse` schema
  - Created typed `usePositions` hook (`src/hooks/usePositions.ts`) that fetches from the API with query params and auth token
  - TypeScript typecheck and Vite production build both pass
- Files changed:
  - `frontend/package.json` (modified — added @tanstack/react-table, @tanstack/react-query, devtools)
  - `frontend/src/main.tsx` (modified — added QueryClientProvider + ReactQueryDevtools)
  - `frontend/src/types/position.ts` (new — Position type with computed fields)
  - `frontend/src/hooks/usePositions.ts` (new — typed usePositions query hook)
- **Learnings:**
  - `@tanstack/react-query-devtools` is a devDependency; it auto-hides in production builds
  - Position types use `number` for backend `Decimal` fields (JSON serializes as number)
  - `useQuery` generic parameter `useQuery<Position[]>` provides return type inference
  - `VITE_API_URL` env var used for API base URL with fallback to localhost:8000
---

## 2026-02-22 - US-017
- What was implemented:
  - Installed `react-router` (v7) for client-side routing
  - Created route configuration in `App.tsx`: `/login` (public), `/` (Open Positions), `/history`, `/dashboard`, `/settings` (all authenticated)
  - Created `Layout` component with persistent sidebar nav using `NavLink` for active state highlighting
  - Created `AuthGuard` component that wraps authenticated routes and redirects to `/login` when no user
  - Created placeholder page components: `OpenPositions`, `History`, `Dashboard`, `Settings`, `Login`
  - Created `useAuth` hook (stub) returning a dev user — to be replaced by Supabase auth in US-018
  - Layout uses nested `<Route>` + `<Outlet>` pattern for shared sidebar across authenticated pages
- Files changed:
  - `frontend/package.json` (modified — added react-router)
  - `frontend/src/App.tsx` (rewritten — router configuration)
  - `frontend/src/components/Layout.tsx` (new — sidebar nav + content outlet)
  - `frontend/src/components/AuthGuard.tsx` (new — auth guard with redirect)
  - `frontend/src/hooks/useAuth.ts` (new — auth stub)
  - `frontend/src/pages/OpenPositions.tsx` (new — placeholder)
  - `frontend/src/pages/History.tsx` (new — placeholder)
  - `frontend/src/pages/Dashboard.tsx` (new — placeholder)
  - `frontend/src/pages/Settings.tsx` (new — placeholder)
  - `frontend/src/pages/Login.tsx` (new — placeholder)
- **Learnings:**
  - React Router v7 uses `react-router` package (not `react-router-dom`); `BrowserRouter`, `Routes`, `Route` all from `react-router`
  - `NavLink` with `className` callback `({ isActive }) => ...` provides active state styling
  - Nested `<Route element={<AuthGuard />}>` with `<Outlet />` cleanly wraps all authenticated routes
  - `end` prop on NavLink for `/` index route prevents it from matching all paths
  - Layout route pattern: `<Route element={<Layout />}>` → child routes render inside Layout's `<Outlet />`
---

## 2026-02-22 - US-018
- What was implemented:
  - Installed `@supabase/supabase-js` and created Supabase client (`src/lib/supabase.ts`) using `VITE_SUPABASE_URL` and `VITE_SUPABASE_ANON_KEY`
  - Created `AuthProvider` context (`src/contexts/AuthContext.tsx`) exposing: `user`, `session`, `loading`, `signIn`, `signOut`
  - Auth state initialized from `supabase.auth.getSession()` and kept in sync via `onAuthStateChange` listener
  - Token refresh is handled automatically by the Supabase client (built-in)
  - Updated `useAuth` hook to consume the real `AuthContext` (replaced dev stub)
  - Created `apiFetch` utility (`src/lib/api.ts`) that attaches `Authorization: Bearer <token>` automatically
  - Updated `usePositions` hook to get token from auth context and pass to `apiFetch`
  - Wrapped App with `AuthProvider` in `main.tsx`
- Files changed:
  - `frontend/package.json` (modified — added @supabase/supabase-js)
  - `frontend/src/lib/supabase.ts` (new — Supabase client initialization)
  - `frontend/src/lib/api.ts` (new — fetch wrapper with auth token)
  - `frontend/src/contexts/AuthContext.tsx` (new — AuthProvider with signIn/signOut)
  - `frontend/src/hooks/useAuth.ts` (rewritten — now uses AuthContext)
  - `frontend/src/hooks/usePositions.ts` (modified — uses apiFetch + auth token from context)
  - `frontend/src/main.tsx` (modified — wrapped with AuthProvider)
- **Learnings:**
  - `@supabase/supabase-js` handles token refresh internally via `onAuthStateChange` with `TOKEN_REFRESHED` event
  - `supabase.auth.getSession()` returns the initial session (from localStorage); `onAuthStateChange` keeps it updated
  - React 19 context uses `<AuthContext value={...}>` (not `.Provider`) via the new context API
  - `session.access_token` is the JWT to send to the backend; session is `null` when not authenticated
  - `enabled: !!token` in useQuery prevents API calls when not authenticated
---

## 2026-02-22 - US-019
- What was implemented:
  - Built Login page with email/password form using shadcn/ui Card, Input, Label, Button components
  - Form calls `signIn(email, password)` from AuthContext on submit
  - Failed login displays error message below form fields
  - Successful login triggers auth state change → AuthGuard allows access → redirects to `/`
  - Already-authenticated users visiting `/login` are redirected to `/` via `<Navigate />`
  - Added shadcn/ui Input, Label, Card components via `npx shadcn@latest add`
- Files changed:
  - `frontend/src/pages/Login.tsx` (rewritten — full login form with error handling)
  - `frontend/src/components/ui/input.tsx` (new — shadcn/ui Input)
  - `frontend/src/components/ui/label.tsx` (new — shadcn/ui Label)
  - `frontend/src/components/ui/card.tsx` (new — shadcn/ui Card)
- **Learnings:**
  - shadcn/ui Card has subcomponents: CardHeader, CardTitle, CardDescription, CardContent, CardFooter
  - Login redirect flow: signIn → Supabase updates session → onAuthStateChange fires → user state updates → AuthGuard re-renders → allows access
  - `<Navigate to="/" replace />` for already-authenticated users prevents login page flash
  - `disabled={submitting}` on Button prevents double-submit; `try/catch/finally` ensures `setSubmitting(false)` always runs
---

## 2026-02-22 - US-020
- What was implemented:
  - Enhanced `apiFetch` with 401 token refresh: on 401, calls `supabase.auth.refreshSession()`, retries with new token; on refresh failure, redirects to `/login`
  - Created typed API functions for all backend endpoints: `getAccounts`, `createAccount`, `updateAccount`, `getPositions`, `createPosition`, `updatePosition`, `closePosition`, `rollPosition`, `getDashboardSummary`, `getDashboardByTicker`
  - Created TypeScript types for `Account`, `AccountCreate`, `AccountUpdate` (`src/types/account.ts`)
  - Created TypeScript types for `DashboardSummary`, `TickerSummary` (`src/types/dashboard.ts`)
  - Updated `usePositions` hook to use typed `getPositions` and `PositionFilters` from API client
  - API base URL configurable via `VITE_API_BASE_URL` env var
- Files changed:
  - `frontend/src/lib/api.ts` (rewritten — full API client with 401 handling and typed functions)
  - `frontend/src/types/account.ts` (new — Account types)
  - `frontend/src/types/dashboard.ts` (new — Dashboard types)
  - `frontend/src/hooks/usePositions.ts` (simplified — uses getPositions from api.ts)
- **Learnings:**
  - 401 interceptor pattern: check `res.status === 401`, try `supabase.auth.refreshSession()`, retry with new token, redirect on failure
  - `window.location.href = "/login"` is a hard redirect (full page reload) — appropriate for auth failure to clear all state
  - Typed API functions follow consistent pattern: `functionName(params, token)` → `apiFetch<ReturnType>(path, token, options)`
  - `Object.entries(params)` + `URLSearchParams` for clean query string building from filter objects
---

## 2026-02-22 - US-021
- What was implemented:
  - Built account management section on the Settings page with table showing name, broker, tax treatment
  - Add Account button opens `AccountFormDialog` modal with name (text), broker (Select dropdown: robinhood, merrill, other), optional tax treatment
  - Edit button on each row opens same dialog pre-filled with existing account data
  - `useAccounts`, `useCreateAccount`, `useUpdateAccount` hooks using TanStack Query mutations with `invalidateQueries` on success
  - Account list auto-refreshes after add/edit via query invalidation
  - Added shadcn/ui Dialog and Select components
- Files changed:
  - `frontend/src/pages/Settings.tsx` (rewritten — account management section)
  - `frontend/src/components/AccountFormDialog.tsx` (new — add/edit account modal)
  - `frontend/src/hooks/useAccounts.ts` (new — useAccounts, useCreateAccount, useUpdateAccount)
  - `frontend/src/components/ui/dialog.tsx` (new — shadcn/ui Dialog)
  - `frontend/src/components/ui/select.tsx` (new — shadcn/ui Select)
- **Learnings:**
  - `useMutation` + `onSuccess: () => queryClient.invalidateQueries({ queryKey: ["accounts"] })` auto-refreshes the list after mutations
  - Single `AccountFormDialog` component handles both add and edit by checking for `account` prop
  - `useEffect` on `[account, open]` resets form state when dialog opens (prevents stale data)
  - shadcn/ui Select uses Radix primitives: `SelectTrigger`, `SelectValue`, `SelectContent`, `SelectItem`
---

## 2026-02-22 - US-022
- What was implemented:
  - Created `PositionsTable` component using TanStack Table with `useReactTable`, `getCoreRowModel`, `getSortedRowModel`
  - Defined `openPositionColumns` column definitions with formatters: currency (Intl.NumberFormat), percent, abbreviations (CC/CSP)
  - All columns support sorting via `getToggleSortingHandler()` with arrow indicators
  - Sticky header via `sticky top-0` class on TableHeader
  - Empty state with dashed border and prompt message
  - Loading and error states shown on the OpenPositions page
  - Data fetched via `usePositions({ status: "OPEN" })` using TanStack Query
  - Added shadcn/ui Table component
- Files changed:
  - `frontend/src/components/PositionsTable.tsx` (new — TanStack Table with columns and sorting)
  - `frontend/src/pages/OpenPositions.tsx` (rewritten — uses PositionsTable with data fetching)
  - `frontend/src/components/ui/table.tsx` (new — shadcn/ui Table)
- **Learnings:**
  - TanStack Table column definitions: `accessorKey` for data binding, `header` for display name, `cell` for custom rendering
  - `getSortedRowModel()` enables client-side sorting; `onSortingChange` + `state.sorting` for controlled state
  - `getToggleSortingHandler()` returns an event handler for click-to-sort headers
  - `flexRender()` is used to render both header and cell content from column definitions
  - Separate `openPositionColumns` export allows reuse and customization for different table views
---
