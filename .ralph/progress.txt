## Codebase Patterns
- Close/action endpoints: Use `POST /{id}/action` pattern; check status before mutating to return 400 for invalid state
- Literal types: Use `Literal["A", "B", "C"]` in Pydantic schemas for subset validation (e.g., close outcome excludes ROLLED)
- List endpoints: Use `Optional` query params with `Query(None)`, chain `.filter()` conditionally
- _FakeQuery: Add `.order_by()` method for mock chaining on list endpoints
- Compound endpoints: Use nested Pydantic schemas (e.g., `PositionRoll` with `close` and `open` sub-objects) for multi-operation payloads
- Atomicity: Single `db.commit()` after all mutations ensures both close + create happen in one transaction
- Config: Use pydantic-settings with `get_settings()` + `@lru_cache` for lazy loading
- Database: `app/database.py` has `Base`, `SessionLocal`, `get_db()` dependency
- Alembic: env.py imports `get_settings()` and `Base` from app modules
- Alembic migrations: Manual revision IDs (0002, 0003, ...), use `sa.text()` for server_default
- Migration tests: Use `importlib.util.spec_from_file_location` to load, mock `op` to verify structure
- ForeignKeyConstraint: Use `.column_keys` not `.columns` for unbound constraints
- Python: asdf with `.tool-versions` (python 3.10.4)
- Backend venv: `backend/.venv/` — activate with `source .venv/bin/activate`
- Tests: `backend/tests/` with pytest, run from backend dir
- Frontend: Vite + React 19 + TypeScript 5.9, strict mode
- CheckConstraint: Pass as positional arg to `op.create_table`, test via `isinstance(a, sa.CheckConstraint)`
- PostgreSQL arrays: Use `sa.ARRAY(sa.Text())` for `text[]` columns
- Indexes: `op.create_index` after `create_table`; test via `mock_op.create_index.call_args_list`
- Models: SQLAlchemy 2.0 `Mapped[]` + `mapped_column()` style in `app/models/`
- Models: `user_id` is plain Uuid (no FK in ORM) since FK targets cross-schema `auth.users.id`
- Models: Use `TYPE_CHECKING` guard for circular relationship imports between Account/Position
- Model tests: Use `sa_inspect(Model)` to verify columns, types, relationships without live DB
- Test env: `conftest.py` sets dummy env vars via `os.environ.setdefault` before app imports
- Auth: `app/auth.py` has `JWTAuthMiddleware` + `get_current_user` dependency returning `UUID`
- Auth: JWT verified via PyJWT with HS256, audience="authenticated", secret from `SUPABASE_JWT_SECRET`
- Auth: Public paths (`/health`, `/docs`, `/openapi.json`, `/redoc`) excluded in middleware
- Auth tests: Register test-only route at module level in test file, use `_make_token()` helper
- Schemas: `app/schemas/` with enums.py, account.py, position.py; all use Pydantic v2 `model_config`
- Schemas: `PositionResponse` uses `@computed_field` + `@property` for premium_total, premium_net, collateral, roc_period, dte, annualized_roc
- Schemas: `from_attributes=True` enables ORM model → Pydantic response via `model_validate(orm_obj)`
- Schemas: Enums are `str, Enum` subclasses for JSON serialization and string comparison
- Schemas: Access `model_fields` on the class, not the instance (Pydantic v2.11 deprecation)
- Routers: `app/routers/` with APIRouter, prefix `/api/v1/<resource>`, wired via `app.include_router()` in main.py
- Router tests: Use `app.dependency_overrides[get_db]` to inject mock DB session; clear in `finally` block
- Router tests: `_FakeQuery` helper class chains `.filter().all()` / `.filter().first()` for mock DB queries
- Router tests: Use `_make_account()` / `_make_token()` helpers for test fixtures
- Enum values: When storing Broker enum to DB, use `.value` to get the string (e.g., `body.broker.value`)
- PATCH pattern: `model_dump(exclude_unset=True)` + `setattr` loop; handle `.value`/`.upper()` in the loop
- Mock query sequencing: `mock_db.query.side_effect = [query1, query2]` for multiple distinct queries in one endpoint

---

## 2026-02-22 - US-001
- What was implemented:
  - Created `.env.example` documenting all required environment variables (SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY, DATABASE_URL, VITE_* frontend vars)
  - Created `backend/app/config.py` with pydantic-settings `Settings` class and lazy `get_settings()` loader
  - Created `backend/app/database.py` with SQLAlchemy engine, SessionLocal, Base, and `get_db()` dependency
  - Initialized Alembic (`backend/alembic/`) and configured `env.py` to use app config and Base metadata
  - Added `.tool-versions` for Python 3.10.4 via asdf
  - Created `backend/requirements-dev.txt` with test dependencies
  - Created initial tests (`tests/test_config.py`) for settings loading and health endpoint
- Files changed:
  - `.env.example` (new)
  - `.tool-versions` (new)
  - `backend/app/config.py` (new)
  - `backend/app/database.py` (new)
  - `backend/alembic/` (new — initialized)
  - `backend/alembic.ini` (new — generated)
  - `backend/alembic/env.py` (modified — connected to app config)
  - `backend/requirements-dev.txt` (new)
  - `backend/tests/__init__.py` (new)
  - `backend/tests/test_config.py` (new)
- **Learnings:**
  - pydantic-settings eagerly validates at import time; use `@lru_cache` + getter function to avoid import-time failures in tests
  - Alembic init generates a default env.py that needs to be wired to the app's Base.metadata and config
  - The project uses asdf for version management; must set `.tool-versions` before Python commands work
---

## 2026-02-22 - US-002
- What was implemented:
  - Created Alembic migration `0002_create_accounts_table.py` with all required columns (id, user_id, name, broker, tax_treatment, created_at, updated_at)
  - id is uuid PK with `gen_random_uuid()` server default
  - user_id has FK constraint to `auth.users.id` (Supabase auth)
  - created_at and updated_at use `now()` server defaults with timezone=True
  - Downgrade drops the table
  - Created `tests/test_migrations.py` with 8 tests verifying migration structure via mocked `op`
- Files changed:
  - `backend/alembic/versions/0002_create_accounts_table.py` (new)
  - `backend/tests/test_migrations.py` (new)
- **Learnings:**
  - `ForeignKeyConstraint.columns` is empty until bound to a table; use `.column_keys` for assertions
  - Can't `importlib.import_module("alembic.versions.xxx")` — alembic.versions is part of alembic's package namespace; use `spec_from_file_location` instead
  - Mocking `op` is a clean way to test migration structure without needing a live database
---

## 2026-02-22 - US-003
- What was implemented:
  - Created Alembic migration `0003_create_positions_table.py` with all 22 columns from the spec
  - Columns: id (uuid PK), user_id, account_id, ticker, type, status (default OPEN), open_date, expiration_date, close_date, strike_price (numeric), contracts (int), multiplier (int default 100), premium_per_share (numeric), open_fees (numeric default 0), close_fees (numeric default 0), close_price_per_share, outcome, roll_group_id, notes, tags (text[]), created_at, updated_at
  - FK constraints to `auth.users.id` and `accounts.id`
  - CHECK constraints on type (COVERED_CALL, CASH_SECURED_PUT), status (OPEN, CLOSED), outcome (EXPIRED, ASSIGNED, CLOSED_EARLY, ROLLED)
  - Three composite indexes: (user_id, status), (user_id, ticker), (user_id, expiration_date)
  - Downgrade drops indexes then table
  - Added 10 tests to `tests/test_migrations.py` covering structure, columns, types, nullability, FKs, CHECKs, indexes, and downgrade
- Files changed:
  - `backend/alembic/versions/0003_create_positions_table.py` (new)
  - `backend/tests/test_migrations.py` (modified — added TestPositionsMigration)
- **Learnings:**
  - `sa.CheckConstraint` objects can be passed as positional args to `op.create_table` alongside columns and FK constraints
  - `sa.ARRAY(sa.Text())` is the correct SQLAlchemy type for PostgreSQL `text[]` columns
  - Indexes created via `op.create_index` are separate calls after `create_table`; test them via `mock_op.create_index.call_args_list`
---

## 2026-02-22 - US-004
- What was implemented:
  - Created `app/models/account.py` — Account ORM model with all 7 columns mapped via `mapped_column()` (SQLAlchemy 2.0)
  - Created `app/models/position.py` — Position ORM model with all 22 columns including `tags` as `ARRAY(Text)`
  - Defined relationships: `Account.positions` (one-to-many) and `Position.account` (many-to-one) with `back_populates`
  - Updated `app/models/__init__.py` to export both models
  - Created `tests/conftest.py` to set dummy env vars for test imports
  - Created `tests/test_models.py` with 16 tests covering columns, types, nullability, PKs, FKs, relationships, and Mapped[] style
- Files changed:
  - `backend/app/models/account.py` (new)
  - `backend/app/models/position.py` (new)
  - `backend/app/models/__init__.py` (modified)
  - `backend/tests/conftest.py` (new)
  - `backend/tests/test_models.py` (new)
- **Learnings:**
  - `user_id` FK to `auth.users.id` (Supabase cross-schema) is omitted from ORM model to avoid metadata resolution issues; migration handles the FK
  - `sa_inspect(Model)` provides clean access to column_attrs, relationships, and primary_key for structural tests
  - `TYPE_CHECKING` guard is needed for circular imports between Account/Position relationship types
  - Column named `type` needs explicit name arg `mapped_column("type", Text, ...)` to avoid ambiguity
  - `conftest.py` with `os.environ.setdefault` is the cleanest way to handle env vars for tests that import app modules
---

## 2026-02-22 - US-005
- What was implemented:
  - Created `app/auth.py` with `JWTAuthMiddleware` (Starlette BaseHTTPMiddleware) and `get_current_user` FastAPI dependency
  - Middleware verifies Supabase JWTs (HS256 + shared secret) on every request except public paths (/health, /docs, /openapi.json, /redoc)
  - Extracts `sub` claim as `user_id`, stores in `request.state.user_id`
  - `get_current_user` reads from `request.state` and returns `UUID`
  - Added `SUPABASE_JWT_SECRET` to Settings config, `.env.example`, and test conftest
  - Added `PyJWT>=2.8` to requirements.txt
  - Wired middleware into `app/main.py`
  - Created `tests/test_auth.py` with 10 tests covering: health bypass, missing header, invalid format, invalid token, expired token, wrong secret, wrong audience, missing sub claim, valid token returns user_id, UUID type check
- Files changed:
  - `backend/app/auth.py` (new)
  - `backend/app/main.py` (modified — added JWTAuthMiddleware)
  - `backend/app/config.py` (modified — added supabase_jwt_secret)
  - `backend/requirements.txt` (modified — added PyJWT)
  - `.env.example` (modified — added SUPABASE_JWT_SECRET)
  - `backend/tests/conftest.py` (modified — added SUPABASE_JWT_SECRET env var)
  - `backend/tests/test_auth.py` (new)
- **Learnings:**
  - Starlette `BaseHTTPMiddleware` with `dispatch()` is the simplest way to add request-level auth in FastAPI
  - PyJWT `jwt.decode()` with `audience` param enforces the `aud` claim automatically
  - `request.state` is the standard way to pass data from middleware to dependencies
  - Register test-only routes at module level (not inside test functions) to avoid issues with FastAPI route registration
  - `HTTPBearer(auto_error=False)` in the dependency prevents double-401 (middleware already handles it)
---

## 2026-02-22 - US-006
- What was implemented:
  - Created `app/schemas/enums.py` with str Enum classes: PositionType, PositionStatus, PositionOutcome, Broker
  - Created `app/schemas/account.py` with AccountCreate, AccountUpdate, AccountResponse (Pydantic v2)
  - Created `app/schemas/position.py` with PositionCreate, PositionUpdate, PositionResponse (Pydantic v2)
  - PositionResponse includes 6 computed fields: premium_total, premium_net, collateral, roc_period, dte, annualized_roc
  - All schemas use `model_config = ConfigDict(...)` (Pydantic v2 style)
  - Response schemas use `from_attributes=True` for ORM compatibility
  - Updated `app/schemas/__init__.py` to re-export all schemas and enums
  - Created `tests/test_schemas.py` with 43 tests covering enums, create/update/response for both accounts and positions, computed field calculations, validation errors, and Pydantic v2 config
- Files changed:
  - `backend/app/schemas/enums.py` (new)
  - `backend/app/schemas/account.py` (new)
  - `backend/app/schemas/position.py` (new)
  - `backend/app/schemas/__init__.py` (modified — added re-exports)
  - `backend/tests/test_schemas.py` (new)
- **Learnings:**
  - Pydantic v2 `@computed_field` requires `@property` decorator underneath and `# type: ignore[prop-decorator]` for mypy
  - `str, Enum` base classes make enums JSON-serializable and comparable to plain strings
  - `from_attributes=True` in model_config enables `ModelClass.model_validate(orm_object)` for ORM → Pydantic conversion
  - `model_fields` should be accessed on the class not instance (deprecated in Pydantic v2.11)
  - Computed fields for annualized_roc need zero-guard on both collateral and days_in_trade
---

## 2026-02-22 - US-007
- What was implemented:
  - Created `app/routers/accounts.py` with 3 CRUD endpoints:
    - `GET /api/v1/accounts` — lists authenticated user's accounts
    - `POST /api/v1/accounts` — creates account with name, broker, optional tax_treatment (returns 201)
    - `PATCH /api/v1/accounts/{id}` — updates account fields; returns 404 if not found or belongs to another user
  - All endpoints use `get_current_user` dependency to scope queries by `user_id`
  - All responses use `AccountResponse` schema with `from_attributes=True` for ORM → Pydantic conversion
  - Wired router into `app/main.py` via `app.include_router()`
  - Created `tests/test_accounts.py` with 13 tests covering: list (2), auth (1), create (4), update (5), schema validation (1)
  - Tests use `dependency_overrides[get_db]` with mock DB session (no live DB needed)
- Files changed:
  - `backend/app/routers/accounts.py` (new)
  - `backend/app/main.py` (modified — added router import and include)
  - `backend/tests/test_accounts.py` (new)
- **Learnings:**
  - `app.dependency_overrides[get_db]` is the standard FastAPI testing pattern to inject mock DB without real connections
  - Broker enum `.value` must be extracted when setting on ORM model to store the raw string
  - `exclude_unset=True` in `model_dump()` is critical for PATCH — only applies fields the client actually sent
  - Filter by both `Account.id == account_id` and `Account.user_id == user_id` in a single query ensures user isolation and returns 404 for other users' accounts
---

## 2026-02-22 - US-008
- What was implemented:
  - Created `app/routers/positions.py` with `POST /api/v1/positions` endpoint
  - Validates `account_id` belongs to authenticated user (returns 400 if not)
  - Uppercases `ticker` before storage
  - Creates position with all required fields + optional fields (multiplier, open_fees, notes, tags)
  - Returns `PositionResponse` with computed fields (premium_total, premium_net, collateral, roc_period, dte, annualized_roc)
  - Wired router into `app/main.py` via `app.include_router()`
  - Created `tests/test_positions.py` with 9 tests covering: success, ticker uppercase, invalid account (400), optional fields, auth required (401), missing fields (422), invalid type (422), computed fields verification, CASH_SECURED_PUT type
- Files changed:
  - `backend/app/routers/positions.py` (new)
  - `backend/app/main.py` (modified — added positions router)
  - `backend/tests/test_positions.py` (new)
- **Learnings:**
  - Account ownership validation for positions uses same `_FakeQuery` pattern but returns 400 (not 404) since it's a validation error on the request body
  - `body.type.value` extracts the enum string value for storage in the ORM model (same pattern as Broker enum)
  - `body.ticker.upper()` handles ticker uppercasing at the router level, not schema level
  - Mock `db.refresh()` side_effect must set all fields the ORM object would have after DB round-trip, including server defaults (status, close_fees, etc.)
---

## 2026-02-22 - US-009
- What was implemented:
  - Added `GET /api/v1/positions` endpoint to `app/routers/positions.py` with filtering and sorting
  - Supports query params: status, ticker, type, account_id, expiration_start, expiration_end, sort, order (asc/desc)
  - Default sort is `open_date` descending
  - Ticker filter is case-insensitive (uppercased before comparison)
  - Invalid sort columns fall back to `open_date`
  - Returns empty list (not error) when no positions match
  - Each position includes computed fields via `PositionResponse`
  - Added 11 tests covering: list (2), filters (status, ticker, type, account_id, expiration range), sorting (2), computed fields, auth
  - Updated `_FakeQuery` to support `.order_by()` chaining
- Files changed:
  - `backend/app/routers/positions.py` (modified — added GET endpoint, imports, SORTABLE_COLUMNS)
  - `backend/tests/test_positions.py` (modified — added 11 GET tests, updated _FakeQuery)
- **Learnings:**
  - `Optional` query params with `Query(None)` cleanly handle optional filters — only add `.filter()` when param is not None
  - `getattr(Position, sort_col_name)` dynamically resolves ORM columns for sorting; validate against a whitelist to prevent injection
  - Enum query params (PositionStatus, PositionType) are auto-validated by FastAPI; use `.value` to compare against DB strings
  - `_FakeQuery.order_by()` just returns `self` since mock doesn't need real sorting — tests verify the endpoint accepts sort params without error
---

## 2026-02-22 - US-010
- What was implemented:
  - Added `PATCH /api/v1/positions/{id}` endpoint to `app/routers/positions.py`
  - Updates any subset of editable fields via `PositionUpdate` schema (excludes `user_id`, `status`, `outcome`)
  - Returns 404 if position doesn't exist or belongs to another user
  - Cannot change `user_id` (field not in `PositionUpdate` schema, so it's silently ignored)
  - Ticker is uppercased if provided; type enum stored as `.value` string
  - Validates new `account_id` belongs to user if provided (returns 400 if not)
  - `updated_at` refreshed via `db.commit()` + `db.refresh()` (server-side default)
  - Response includes recalculated computed fields
  - Added 11 tests covering: success, not found, other user's position, cannot change user_id, ticker uppercase, type enum storage, invalid account_id, updated_at refresh, computed fields, auth required, exclude_unset behavior
- Files changed:
  - `backend/app/routers/positions.py` (modified — added PATCH endpoint, imported PositionUpdate)
  - `backend/tests/test_positions.py` (modified — added 11 PATCH tests)
- **Learnings:**
  - `model_dump(exclude_unset=True)` is critical for PATCH — only applies fields the client actually sent, preserving other fields
  - When an endpoint makes multiple different `db.query()` calls (e.g., Position lookup then Account validation), use `mock_db.query.side_effect = [query1, query2]` instead of `return_value`
  - Enum and ticker transformations (`.value`, `.upper()`) should happen in the `setattr` loop to handle both create and update consistently
  - `PositionUpdate` schema excluding `user_id` is the cleanest way to enforce "cannot change user_id" — no explicit validation needed
---

## 2026-02-22 - US-011
- What was implemented:
  - Added `PositionClose` Pydantic schema with `outcome` (Literal["EXPIRED", "ASSIGNED", "CLOSED_EARLY"]), `close_date`, optional `close_price_per_share`, optional `close_fees`
  - Added `POST /api/v1/positions/{id}/close` endpoint to `app/routers/positions.py`
  - Endpoint looks up position by id + user_id, returns 404 if not found
  - Returns 400 if position is already CLOSED
  - Sets status to CLOSED, outcome, close_date, and optional close_price_per_share/close_fees
  - Response includes recalculated computed fields (premium_net reflects close_fees)
  - Added 10 tests covering: success, ASSIGNED outcome, CLOSED_EARLY with close_price/fees, already closed (400), not found (404), other user (404), invalid outcome ROLLED (422), computed fields verification, auth required (401), missing required fields (422)
- Files changed:
  - `backend/app/schemas/position.py` (modified — added PositionClose)
  - `backend/app/schemas/__init__.py` (modified — added PositionClose export)
  - `backend/app/routers/positions.py` (modified — added close endpoint, imported PositionClose)
  - `backend/tests/test_positions.py` (modified — added 10 close tests)
- **Learnings:**
  - `Literal["EXPIRED", "ASSIGNED", "CLOSED_EARLY"]` in Pydantic schema is cleaner than a separate enum for subset validation — gives automatic 422 for ROLLED
  - Action endpoints (close, roll) use `POST /{id}/action` pattern vs `PATCH /{id}` for updates
  - Check `position.status == "CLOSED"` before mutating to return 400 for already-closed positions
  - Optional close fields (`close_price_per_share`, `close_fees`) only set when provided (not None) to avoid overwriting defaults
---

## 2026-02-22 - US-012
- What was implemented:
  - Added `PositionRollClose`, `PositionRoll`, and `PositionRollResponse` Pydantic schemas to `app/schemas/position.py`
  - `PositionRoll` uses nested schemas: `close` (PositionRollClose) and `open` (PositionCreate) for the two-part payload
  - `PositionRollResponse` returns both `closed` and `opened` PositionResponse objects
  - Added `POST /api/v1/positions/{id}/roll` endpoint to `app/routers/positions.py`
  - Endpoint: looks up position (404 if not found), checks not already closed (400), validates new account_id (400), generates shared `roll_group_id`, closes old position with outcome=ROLLED, creates new position, single `db.commit()` for atomicity
  - Returns both closed and opened positions with computed fields
  - Updated `app/schemas/__init__.py` to export new schemas
  - Added 11 tests covering: success, close_price/fees, not found (404), other user (404), already closed (400), invalid account (400), atomic transaction, ticker uppercase, computed fields, auth required (401), missing fields (422)
- Files changed:
  - `backend/app/schemas/position.py` (modified — added PositionRollClose, PositionRoll, PositionRollResponse)
  - `backend/app/schemas/__init__.py` (modified — added new exports)
  - `backend/app/routers/positions.py` (modified — added roll endpoint, imported new schemas + uuid4)
  - `backend/tests/test_positions.py` (modified — added 11 roll tests)
- **Learnings:**
  - Nested Pydantic schemas (close + open sub-objects) cleanly model compound operations like roll
  - Reusing `PositionCreate` as the `open` field type in `PositionRoll` avoids duplicating validation logic
  - Single `db.commit()` after both close mutation and `db.add(new_position)` ensures atomicity without explicit transaction management
  - `mock_db.query.side_effect = [position_query, account_query]` handles the two sequential queries (Position lookup then Account validation)
  - `fake_refresh` with a counter (`refresh_call_count`) differentiates between refreshing the closed position vs the new position
  - Outcome is hardcoded to "ROLLED" in the endpoint (not sent by client), unlike the close endpoint which accepts outcome from the client
---
